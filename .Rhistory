library(readxl)
library(dplyr)
poste <- read.csv2('seznam 2.csv')
poste <- poste[-c(1,2),-c(1,4)]
library(readxl)
library(dplyr)
poste <- read.csv2(file = "seznam_2.csv")
poste <- poste[-c(1,2),-c(1,4)]
View(poste)
names(poste) <- c('postna_st', 'posta')
#odstranimo nekaj ponavljajocih se post (Lj, Mb, Kp), da lahko uporabimo vektorske funkcije
poste <- poste[-c(201:240),]
poste <- poste[-c(273:282),]
poste <- poste[-c(159:161),]
osebe <- read.csv('osebe.csv')
osebe$prebivalisce <- sample(poste$posta)
View(osebe)
poste$postna_st <- as.numeric(poste$postna_st)
seznam_post <- read.csv2(file = "seznam_1.csv")
View(seznam_post)
seznam_post <- read.csv2(file = "seznam_1.csv")
View(seznam_post)
#Najprej uvozimo seznam post.
poste <- read.csv2(file = "seznam_1.csv")
#odstranimo nekaj ponavljajocih se post (Lj, Mb, Kp), da lahko uporabimo vektorske funkcije
poste <- poste[-c(201:240),]
poste <- poste[-c(273:282),]
poste <- poste[-c(159:161),]
#Nato uvozimo tabelo osebe
osebe <- read.csv('osebe.csv')
osebe$prebivalisce <- sample(poste$posta)
#novo zgenerirana baza, 10 000 podatkov - boljse kot prejsnja, ki jih je imela samo 1000
posiljke <- read.csv('posiljkee.csv')
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
View(posiljke)
#k tabeli posiljke smo dodali posiljatelja in naslovnika, od koder lahko tudi razberemo
#vstopno in izstopno mesto posiljke
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime)
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#k tabeli posiljke smo dodali posiljatelja in naslovnika, od koder lahko tudi razberemo
#vstopno in izstopno mesto posiljke
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
View(poste)
colnames(poste) <- c(postna_st, naziv_poste)
colnames(poste) <- c("postna_st", "naziv_poste")
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
vmesno_nahajalisce <- posiljke
vmesno_nahajalisce <- vmesno_nahajalisce[,-c(2,3,5,6,7)]
View(vmesno_nahajalisce)
View(posiljke)
posiljke$vmesni_kraj <- NULL
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#k tabeli posiljke smo dodali posiljatelja in naslovnika, od koder lahko tudi razberemo
#vstopno in izstopno mesto posiljke
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Naredimo se tabelo za vmesno nahajalisce.
vmesno_nahajalisce <- posiljke
vmesno_nahajalisce <- vmesno_nahajalisce[,-c(2,3,5,6,7)]
posiljke <- posiljke[,-c(4,8)]
install.packages(c("dbplyr", "RPostgreSQL"))
View(osebe)
View(poste)
View(posiljke)
View(vmesno_nahajalisce)
View(osebe)
View(osebe)
source('C:/Users/Uporabnik/Fax/OPB/Iskalnik-postnih-posiljk/uvoz.R')
library(dplyr)
source('C:/Users/Uporabnik/Fax/OPB/Iskalnik-postnih-posiljk/uvoz.R')
osebe$prebivalisce <- sample(poste$posta) #Premesamo stolpec posta
source('C:/Users/Uporabnik/Fax/OPB/Iskalnik-postnih-posiljk/uvoz.R')
View(poste)
osebe$prebivalisce <- sample(poste$posta) #Premesamo stolpec posta
osebe$prebivalisce1 <- poste$naziv_poste
osebe$prebivalisce2 <- sample(poste$naziv_poste) #Premesamo stolpec posta
source('C:/Users/Uporabnik/Fax/OPB/Iskalnik-postnih-posiljk/uvoz.R')
View(osebe)
source('U:/OPB/Iskalnik-postnih-posiljk/povezava.R')
osebe$prebivalisce <- sample(poste$naziv_poste) #Premesamo stolpec posta
library(readxl)
library(dplyr)
#Najprej uvozimo seznam post.
poste <- read.csv2(file = "seznam_1.csv")
#odstranimo nekaj ponavljajocih se post (Lj, Mb, Kp), da lahko uporabimo vektorske funkcije
poste <- poste[-c(201:240),]
poste <- poste[-c(273:282),]
poste <- poste[-c(159:161),]
colnames(poste) <- c("postna_st", "naziv_poste")
#Nato uvozimo tabelo osebe
osebe <- read.csv('osebe.csv')
#Treba je pretvoriti stolpca uporabnisko_ime in telefonska v numeric.
osebe$prebivalisce <- sample(poste$naziv_poste) #Premesamo stolpec posta
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#k tabeli posiljke smo dodali posiljatelja in naslovnika, od koder lahko tudi razberemo
#vstopno in izstopno mesto posiljke
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#stolpec datum, datum_postaja in datum_prispe moramo pretvorit v date?
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Naredimo se tabelo za vmesno nahajalisce.
vmesno_nahajalisce <- posiljke
vmesno_nahajalisce <- vmesno_nahajalisce[,-c(2,3,5,6,7)]
#Zdaj lahko izbrisemo vmesno postajo iz tabele posiljke.
posiljke <- posiljke[,-c(4,8)]
library(RPostgreSQL)
library(dplyr)
library(dbplyr)
#Uvoz:
source("auth.R", encoding="UTF-8")
#source("auth_public.R", encoding="UTF-8")
source("uvoz.r", encoding="UTF-8")
# Povezemo se z gonilnikom za PostgreSQL
drv <- dbDriver("PostgreSQL")
# Funkcija za brisanje tabel
# Funkcija za brisanje tabel
delete_table <- function(){
# Uporabimo funkcijo tryCatch,
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo z bazo
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
# Če tabela obstaja, jo zbrišemo, ter najprej zbrišemo tiste,
# ki se navezujejo na druge
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS oseba CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posta CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljka  CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljatelj  CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS naslovnik CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
}, finally = {
dbDisconnect(conn)
})
}
#Funkcija, ki ustvari tabele
create_table <- function(){
# Uporabimo tryCatch (da se poveĹľemo in bazo in odveĹľemo)
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
# Glavne tabele
osebe <- dbSendQuery(conn, build_sql("CREATE TABLE osebe (
uporabnisko_ime INTEGER PRIMARY KEY,
ime text NOT NULL,
priimek text NOT NULL,
tel_st INTEGER NOT NULL,
email text NOT NULL,
naslov text NOT NULL,
odda INTEGER NOT NULL)"))
poste <- dbSendQuery(conn, build_sql("CREATE TABLE poste(
postna_stevilka INTEGER REFERENCES oseba(odda),
kraj text NOT NULL)"))
posiljke <- dbSendQuery(conn, build_sql("CREATE TABLE posiljke(
id_posiljke INTEGER PRIMARY KEY,
teza INTEGER NOT NULL,
odkupnina INTEGER NOT NULL,
datum_oddaje DATE NOT NULL,
naslovnik INTEGER REFERENCES oseba(emso)),
posiljatelj INTEGER REFERENCES oseba(emso)"))
# vmesno_nahajalisce <- dbSendQuery(conn, build_sql("CREATE TABLE vmesno_nahajalisce(
#
#                                                   vmesni_kraj INTEGER REFERENCES posta(emso)
#                                                   vmesna_postaja
# )")
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO  anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO javnost"))
dbSendQuery(conn, build_sql("GRANT SELECT ON ALL TABLES IN SCHEMA public TO javnost"))
},
finally = {
# Na koncu nujno prekinemo povezavo z bazo,
# saj preveÄŤ odprtih povezav ne smemo imeti
dbDisconnect(conn) #PREKINEMO POVEZAVO
# Koda v finally bloku se izvede, preden program konÄŤa z napako
})
}
insert_data <- function(){
tryCatch({
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
dbWriteTable(conn, name="osebe", osebe, append=T, row.names=FALSE)
dbWriteTable(conn, name="posiljke", posiljke, append=T, row.names=FALSE)
}, finally = {
dbDisconnect(conn)
})
}
pravice <- function(){
# Uporabimo tryCatch,(da se povežemo in bazo in odvežemo)
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo
conn <- dbConnect(drv, dbname = db, host = host,#drv=s čim se povezujemo
user = user, password = password)
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO javnost"))
dbSendQuery(conn, build_sql("GRANT SELECT ON ALL TABLES IN SCHEMA public TO javnost"))
}, finally = {
# Na koncu nujno prekinemo povezavo z bazo,
# saj preveč odprtih povezav ne smemo imeti
dbDisconnect(conn) #PREKINEMO POVEZAVO
# Koda v finally bloku se izvede, preden program konča z napako
})
}
pravice()
delete_table()
create_table()
insert_data()
#Uvoz:
source("auth.R", encoding="UTF-8")
#source("auth_public.R", encoding="UTF-8")
source("uvoz.r", encoding="UTF-8")
# Povezemo se z gonilnikom za PostgreSQL
drv <- dbDriver("PostgreSQL")
# Funkcija za brisanje tabel
delete_table <- function(){
# Uporabimo funkcijo tryCatch,
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo z bazo
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
# Če tabela obstaja, jo zbrišemo, ter najprej zbrišemo tiste,
# ki se navezujejo na druge
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS oseba CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posta CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljka  CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljatelj  CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS naslovnik CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
}, finally = {
dbDisconnect(conn)
})
}
View(posiljke)
#stolpca datum_postaja in datum_prispe moramo pretvorit v date?
posiljke$datum_oddaje <- as.Date(posiljke$datum_oddaje)
#stolpca datum_postaja in datum_prispe moramo pretvorit v date?
posiljke$datum_oddaje <- as.date(posiljke$datum_oddaje)
#stolpca datum_postaja in datum_prispe moramo pretvorit v date?
posiljke$datum_oddaje <- as.Date(posiljke$datum_oddaje)
# Skopiraj datoteko v auth.py ali auth.R in vnesi podatke za priklop na bazo
db = 'sem2019_anjazk'
host = 'baza.fmf.uni-lj.si'
user = 'anjazk'
password = 'Zavbi.9.'
library(RPostgreSQL)
library(dplyr)
library(dbplyr)
#Uvoz:
source("auth.R", encoding="UTF-8")
#source("auth_public.R", encoding="UTF-8")
source("uvoz.r", encoding="UTF-8")
# Povezemo se z gonilnikom za PostgreSQL
drv <- dbDriver("PostgreSQL")
# Funkcija za brisanje tabel
delete_table <- function(){
# Uporabimo funkcijo tryCatch,
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo z bazo
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
# Če tabela obstaja, jo zbrišemo, ter najprej zbrišemo tiste,
# ki se navezujejo na druge
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS oseba CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posta CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljka CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS posiljatelj CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS naslovnik CASCADE"))
dbSendQuery(conn,build_sql("DROP TABLE IF EXISTS nahajalisce CASCADE"))
}, finally = {
dbDisconnect(conn)
})
}
#Funkcija, ki ustvari tabele
create_table <- function(){
# Uporabimo tryCatch (da se poveĹľemo in bazo in odveĹľemo)
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
# Glavne tabele
osebe <- dbSendQuery(conn, build_sql("CREATE TABLE osebe (
uporabnisko_ime INTEGER PRIMARY KEY,
ime text NOT NULL,
priimek text NOT NULL,
tel_st INTEGER NOT NULL,
email text NOT NULL,
naslov text NOT NULL,
odda INTEGER NOT NULL)"))
poste <- dbSendQuery(conn, build_sql("CREATE TABLE poste(
postna_stevilka INTEGER REFERENCES oseba(odda),
kraj text NOT NULL)"))
posiljke <- dbSendQuery(conn, build_sql("CREATE TABLE posiljke(
id_posiljke INTEGER PRIMARY KEY,
teza INTEGER NOT NULL,
odkupnina INTEGER NOT NULL,
datum_oddaje DATE NOT NULL,
naslovnik INTEGER REFERENCES oseba(emso)),
posiljatelj INTEGER REFERENCES oseba(emso)"))
# vmesno_nahajalisce <- dbSendQuery(conn, build_sql("CREATE TABLE vmesno_nahajalisce(
#
#                                                   vmesni_kraj INTEGER REFERENCES posta(emso)
#                                                   vmesna_postaja
# )")
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO  anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO javnost"))
dbSendQuery(conn, build_sql("GRANT SELECT ON ALL TABLES IN SCHEMA public TO javnost"))
},
finally = {
# Na koncu nujno prekinemo povezavo z bazo,
# saj preveÄŤ odprtih povezav ne smemo imeti
dbDisconnect(conn) #PREKINEMO POVEZAVO
# Koda v finally bloku se izvede, preden program konÄŤa z napako
})
}
insert_data <- function(){
tryCatch({
conn <- dbConnect(drv, dbname = db, host = host, user = user, password = password)
dbWriteTable(conn, name="osebe", osebe, append=T, row.names=FALSE)
dbWriteTable(conn, name="posiljke", posiljke, append=T, row.names=FALSE)
}, finally = {
dbDisconnect(conn)
})
}
pravice <- function(){
# Uporabimo tryCatch,(da se povežemo in bazo in odvežemo)
# da prisilimo prekinitev povezave v primeru napake
tryCatch({
# Vzpostavimo povezavo
conn <- dbConnect(drv, dbname = db, host = host,#drv=s čim se povezujemo
user = user, password = password)
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL TABLES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anjazk WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ajdas WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO spelao WITH GRANT OPTION"))
dbSendQuery(conn, build_sql("GRANT CONNECT ON DATABASE sem2018_ajdas TO javnost"))
dbSendQuery(conn, build_sql("GRANT SELECT ON ALL TABLES IN SCHEMA public TO javnost"))
}, finally = {
# Na koncu nujno prekinemo povezavo z bazo,
# saj preveč odprtih povezav ne smemo imeti
dbDisconnect(conn) #PREKINEMO POVEZAVO
# Koda v finally bloku se izvede, preden program konča z napako
})
}
pravice()
delete_table()
create_table()
insert_data()
#source("auth_public.R", encoding="UTF-8")
source("uvoz.r", encoding="UTF-8")
library(readr)
library(readxl)
library(dplyr)
library(readxl)
library(readr)
#Najprej uvozimo seznam post.
poste <- read.csv2(file = "seznam_1.csv")
#odstranimo nekaj ponavljajocih se post (Lj, Mb, Kp), da lahko uporabimo vektorske funkcije
poste <- poste[-c(201:240),]
poste <- poste[-c(273:282),]
poste <- poste[-c(159:161),]
colnames(poste) <- c("postna_st", "naziv_poste")
#Nato uvozimo tabelo osebe
osebe <- read.csv('osebe.csv')
View(poste)
View(osebe)
#Treba je pretvoriti stolpca uporabnisko_ime in telefonska v numeric.
osebe$uporabnisko_ime <- gsub("-", "", osebe$uporabnisko_ime) %>% parse_number()
osebe$telefonska <- gsub("-", "", osebe$telefonska) %>% parse_number()
osebe$prebivalisce <- sample(poste$naziv_poste) #Premesamo stolpec posta
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#K tabeli posiljke smo dodale posiljatelja in naslovnika, od koder lahko tudi
#razberemo vstopno in izstopno mesto posiljke.
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
View(posiljke)
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#K tabeli posiljke smo dodale posiljatelja in naslovnika, od koder lahko tudi
#razberemo vstopno in izstopno mesto posiljke.
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
posiljke$datum_prispe <- parse_datetime(posiljke$datum_prispe, format = "%m/%d/%Y %I:%M %p")
posiljke$vmesna_postaja <- parse_datetime(posiljke$vmesna_postaja, format = "%m/%d/%Y %I:%M %p")
#kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
posiljke$datum_prispe <- parse_datetime(posiljke$datum_prispe, format = "%m/%d/%Y %I:%M %p")
posiljke$vmesna_postaja <- parse_datetime(posiljke$vmesna_postaja, format = "%m/%d/%Y %I:%M %p")
#K tabeli posiljke smo dodale posiljatelja in naslovnika, od koder lahko tudi
#razberemo vstopno in izstopno mesto posiljke.
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
library(readxl)
library(dplyr)
library(readr)
#Najprej uvozimo seznam post.
poste <- read.csv2(file = "seznam_1.csv")
#odstranimo nekaj ponavljajocih se post (Lj, Mb, Kp), da lahko uporabimo vektorske funkcije
poste <- poste[-c(201:240),]
poste <- poste[-c(273:282),]
poste <- poste[-c(159:161),]
colnames(poste) <- c("postna_st", "naziv_poste")
#Nato uvozimo tabelo osebe
osebe <- read.csv('osebe.csv')
#Pretvorimo stolpca uporabnisko_ime in telefonska v tip numeric:
osebe$uporabnisko_ime <- gsub("-", "", osebe$uporabnisko_ime) %>% parse_number()
osebe$telefonska <- gsub("-", "", osebe$telefonska) %>% parse_number()
osebe$prebivalisce <- sample(poste$naziv_poste) #Premesamo stolpec posta.
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
posiljke$datum_prispe <- parse_datetime(posiljke$datum_prispe, format = "%m/%d/%Y %I:%M %p")
posiljke$vmesna_postaja <- parse_datetime(posiljke$vmesna_postaja, format = "%m/%d/%Y %I:%M %p")
#K tabeli posiljke smo dodale posiljatelja in naslovnika, od koder lahko tudi
#razberemo vstopno in izstopno mesto posiljke.
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#Kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Naredimo se tabelo za vmesno nahajalisce.
vmesno_nahajalisce <- posiljke
vmesno_nahajalisce <- vmesno_nahajalisce[,-c(2,3,5,6,7)]
#Zdaj lahko izbrisemo vmesno postajo iz tabele posiljke.
posiljke <- posiljke[,-c(4,8)]
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- as.character(posiljke$datum_oddaje)
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
posiljke$datum_prispe <- as.character(posiljke$datum_prispe)
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- as.character(posiljke$datum_oddaje)
#Zgeneriramo se tabelo posiljke, 10 000 podatkov.
posiljke <- read.csv('posiljkee.csv')
#Stolpca datum_postaja in datum_prispe pretvorimo v tip date:
posiljke$datum_oddaje <- as.character(posiljke$datum_oddaje)
posiljke$datum_prispe <- as.character(posiljke$datum_prispe)
posiljke$datum_oddaje <- parse_date(posiljke$datum_oddaje, format = "%m/%d/%Y")
posiljke$datum_prispe <- parse_datetime(posiljke$datum_prispe, format = "%m/%d/%Y %I:%M %p")
posiljke$vmesna_postaja <- as.character(posiljke$vmesna_postaja)
posiljke$vmesna_postaja <- parse_datetime(posiljke$vmesna_postaja, format = "%m/%d/%Y %I:%M %p")
#K tabeli posiljke smo dodale posiljatelja in naslovnika, od koder lahko tudi
#razberemo vstopno in izstopno mesto posiljke.
posiljke$posiljatelj <- osebe$uporabnisko_ime
posiljke$naslovnik <- sample(osebe$uporabnisko_ime) #spet premesamo stolpec
#Kjer je vmesni datum 0, damo tudi da tudi vmesni kraj 0,
#saj je posiljka sla direktno od posiljatelja k naslovniku, ni se vmes ustavljala
posiljke$vmesni_kraj <- sample(poste$postna_st)
#Naredimo se tabelo za vmesno nahajalisce.
vmesno_nahajalisce <- posiljke
vmesno_nahajalisce <- vmesno_nahajalisce[,-c(2,3,5,6,7)]
#Zdaj lahko izbrisemo vmesno postajo iz tabele posiljke.
posiljke <- posiljke[,-c(4,8)]
